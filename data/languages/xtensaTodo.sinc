macro pushVal(val32) {
    local addr:4 = a1;
    a1 = a1 - 4;
    *:4 addr = val32;
}

macro popVal(val32) {
    local addr:4 = a1;
    val32  =  *:4 addr;
    a1 = a1 + 4;
}


macro save() {
      sa3 = a3;
      sa4 = a4;
      sa5 = a5;
      sa6 = a6;
      sa7 = a7;                  
}

macro restore() {
      a3 = sa3;
      a4 = sa4;
      a5 = sa5;
      a6 = sa6;
      a7 = sa7;                  
}


## Windowed Register Option ##

# CALL4 - Call PC-relative, Rotate Window by 4, pg. 298.
:call4 srel_0.17_sb2 is srel_0.17_sb2 & u2_18.19 = 0b01 & op0 = 0b0101 {
    #local dst = srel_0.17_sb2;
    i2=a6;
    i3=a7;
    i4=a8;
    i5=a9;
    a0 = inst_start + 3;
    call srel_0.17_sb2;
    a6=o2;
}

# CALL8 - Call PC-relative, Rotate Window by 8, pg. 300.
:call8 srel_0.17_sb2 is srel_0.17_sb2 & u2_18.19 = 0b10 & op0 = 0b0101 {
    #local dst:4 = 
    i2=a10;
    i3=a11;
    i4=a12;
    i5=a13;
    i6=a14;
    i7=a15;    
    a0 = inst_start + 3;
    call srel_0.17_sb2;
    a10=o2;
}

# CALL12 - Call PC-relative, Rotate Window by 12, pg. 302.
:call12 srel_0.17_sb2 is srel_0.17_sb2 & u2_18.19 = 0b11 & op0 = 0b0101 {
    #local dst = srel_0.17_sb2;
    i2=a14;
    i3=a15;
    a0 = inst_start + 3;
    call srel_0.17_sb2;
    a14=o2;
}

# ENTRY - Subroutine Entry, pg. 340.
:entry as, u15_0.11_sb3 is u15_0.11_sb3 & as & u2_16.17 = 0b00 & u2_18.19 = 0b11 & op0 = 0b0110 {
    local amn = sext(u15_0.11_sb3);
    a2=i2;
    a3=i3;
    a4=i4;
    a5=i5;
    a6=i6;
    a7=i7;        
    #as = as + amn;
    WindowBase    = amn;
    a1 = a1 - amn;
}




# CALLX4 - Call Register, Rotate Window by 4, pg. 305.
:callx4 as is op2 = 0 & op1 = 0 & ar = 0 & as & u2_16.17 = 0b11 & u2_18.19 = 0b01 & op0 = 0 {
    local dst = as;
    i2=a6;
    i3=a7;
    i4=a8;
    i5=a9;
    i6=a10;
    i7=a11;
    a0 = inst_start + 3;
    call [dst];
    a6=o2;
}

# CALLX8 - Call Register, Rotate Window by 8, pg. 307.
:callx8 as is op2 = 0 & op1 = 0 & ar = 0 & as & u2_16.17 = 0b11 & u2_18.19 = 0b10 & op0 = 0 {
    local dst = as;
    i2=a10;
    i3=a11;
    i4=a12;
    i5=a13;
    i6=a14;
    i7=a15;        
    a0 = inst_start + 3;
    call [dst];
    a10=o2;    
}

# CALLX12 - Call Register, Rotate Window by 12, pg. 308.
:callx12 as is op2 = 0 & op1 = 0 & ar = 0 & as & u2_16.17 = 0b11 & u2_18.19 = 0b11 & op0 = 0 {
    local dst = as;
    i2=a14;
    i3=a15;
    a0 = inst_start + 3;
    call [dst];
    a14=o2;
}



# L32E - Load 32-bit for Window Exceptions, pg. 376.
:l32e at, as, s5_12.15_oex is op2 = 0 & op1 = 0b1001 & s5_12.15_oex & as & at & op0 = 0 {
    
}

# MOVSP - Move to Stack Pointer, pg. 427.
:movsp at, as is op2 = 0 & op1 = 0 & ar = 0b0001 & as & at & op0 = 0 unimpl

# RETW - Windowed Return, pg. 480.
:retw is op2 = 0 & op1 = 0 & ar = 0 & as = 0 & u2_16.17 = 0b10 & u2_18.19 = 0b01 & op0 = 0 {
# Assume call8
    o2=a2;
    a1 = a1 + WindowBase;
    return [a0];
}

# RETW.N - Narrow Windowed Return, pg. 482.
:retw.n is n_ar = 0b1111 & n_as = 0 & n_at = 0b0001 & n_op0 = 0b1101 {
    o2=a2;
    a1 = a1 + WindowBase;
    return [a0];
}

# ROTW - Rotate Window, pg. 496.
:rotw u4_16.19 is op2 = 0b0100 & op1 = 0 & ar = 0b1000 & as = 0 & u4_16.19 & op0 = 0 {
    WindowBase = WindowBase + u4_16.19;
}

# S32E - Store 32-bit for Window Exceptions, pg. 508.
:s32e at, as, s5_12.15_oex is op2 = 0b0100 & op1 = 0b1001 & s5_12.15_oex & as & at & op0 = 0 {
	#local vAddr:4 = as + s5_12.15_oex;
	#*:4 vAddr = at;
}


## MAC16 option ##

# LDDEC - Load with Autodecrement, pg. 386.
:lddec "MAC16_REGS[" u2_10.11 "]", as is op2 = 0b1001 & op1 = 0 & u2_8.9 = 0 & u2_10.11 & as & at = 0 & op0 = 0b0100 unimpl

# LDINC - Load with Autoincrement, pg. 387.
:ldinc "MAC16_REGS[" u2_10.11 "]", as is op2 = 0b1000 & op1 = 0 & u2_8.9 = 0 & u2_10.11 & as & at = 0 & op0 = 0b0100 unimpl

# MULA.AA.* - Signed Multiply, pg. 431.
:mula.aa.* as, at is op2 = 0b0001 &u2_18.19 = 0b01 & ar = 0 & as & at & op0 = 0b0100 unimpl

# FIXME: Add remaining MUL.* opcodes.


## Loop Option ##

# LOOP - Loop, pg. 392.
:loop as, urel_0.7 is urel_0.7 & ar = 0b1000 & as & at = 0b0111 & op0 = 0b0110 unimpl

# LOOPGTZ - Loop if Greater Than Zero, pg. 394.
:loopgtz as, urel_0.7 is urel_0.7 & ar = 0b1010 & as & at = 0b0111 & op0 = 0b0110 unimpl

# LOOPNEZ - Loop if Not Equal Zero, pg. 396.
:loopnez as, urel_0.7 is urel_0.7 & ar = 0b1001 & as & at = 0b0111 & op0 = 0b0110 unimpl
